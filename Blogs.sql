-- MySQL dump 10.13  Distrib 5.7.26, for Linux (x86_64)
--
-- Host: localhost    Database: bbs
-- ------------------------------------------------------
-- Server version	5.7.26-0ubuntu0.18.04.1

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `Blog`
--

DROP TABLE IF EXISTS `Blog`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `Blog` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `created_time` int(11) DEFAULT NULL,
  `updated_time` int(11) DEFAULT NULL,
  `title` varchar(64) COLLATE utf8mb4_unicode_ci NOT NULL,
  `content` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `user_id` int(11) NOT NULL,
  `user_name` varchar(50) COLLATE utf8mb4_unicode_ci NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=22 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `Blog`
--

LOCK TABLES `Blog` WRITE;
/*!40000 ALTER TABLE `Blog` DISABLE KEYS */;
INSERT INTO `Blog` VALUES (1,1561890752,1561890752,'markdown demo3','# 示例\r\n\r\n# 标题\r\n\r\n**粗体**\r\n\r\n- 缩进\r\n  - 缩进\r\n\r\n行内高亮： `markdown`\r\n\r\n按键：CTRL\r\n\r\n> 多层引用\r\n> > 多层引用\r\n\r\n———— \r\n\r\n> 单层引用\r\n> 单层引用\r\n\r\n| 表格 | 表格 |\r\n| -    |  -   |\r\n| 表格 | 表格 |\r\n\r\n\r\n图片： ![图片](http://cdn.keyakizaka46.com/files/14/images/common/logo.svg)\r\n\r\n\r\n\r\n代码高亮：\r\n```python\r\ndef dict_recursion(dict_all):\r\n    if isinstance(dict_all, dict):\r\n        for x in dict_all:\r\n            dict_key = x\r\n            dict_value = dict_all[dict_key]\r\n            print(\"{}:{}\".format(dict_key, dict_value))\r\n            dict_recursion(dict_value)\r\n    else:\r\n        return\r\n```',2,'minmin'),(2,1561890752,1561890752,'blog demo','blog demo content',2,'minmin'),(3,1562454629,1562454629,'Markdown cheatsheet','# Headers/見出し/标题\r\n\r\n- 書き方:先頭に#をレベルの数だけ記述。\r\n```\r\n# Header1\r\n## Header2\r\n### Header3\r\n#### Header4\r\n##### Header5\r\n###### Header6\r\n```\r\n- 実際の表示\r\n# Header1\r\n## Header2\r\n### Header3\r\n#### Header4\r\n##### Header5\r\n###### Header6\r\n\r\n# Block/段落/分段\r\n\r\n- 書き方：空白行を挟むことで段落となる。\r\n```\r\n段落1\r\n(空行)\r\n段落2\r\n```\r\n\r\n- 実際の表示\r\n\r\n段落1\r\n\r\n段落2\r\n\r\n# Blockquotes 引用\r\n- 書き方：先頭に```>```を記述。ネストは```>```を多重に記述。\r\n```\r\n> 引用  \r\n> 引用\r\n>> 多重引用\r\n```\r\n\r\n- 実際の表示\r\n> 引用  \r\n> 引用\r\n>> 多重引用\r\n\r\n# Code コード\r\n- 書き方：````````` ３つで囲む。\r\n~~~\r\n```\r\nprint(\'hoge\')\r\n```\r\n~~~\r\n\r\n- 実際の表示\r\n```python\r\nprint(\'hoge\')\r\n```\r\n\r\n- 書き方：```~(ダッシュ)```３つで囲む。\r\n```\r\n~~~\r\nprint(\'hoge\')\r\n~~~\r\n```\r\n- 実際の表示\r\n~~~python\r\nprint(\'hoge\')\r\n~~~\r\n\r\n# インラインコード\r\n`バッククオート` で単語を囲むとインラインコードになる。\r\n```\r\nこれは `インラインコード`です。\r\n```\r\nこれは `インラインコード`です。\r\n\r\n# Hr 水平線\r\nアンダースコア`_` 、アスタリスク`*`、ハイフン`-`などを3つ以上連続して記述。\r\n\r\n```\r\nhoge\r\n***\r\nhoge\r\n___\r\nhoge\r\n---\r\n```\r\n\r\nhoge\r\n***\r\nhoge\r\n___\r\nhoge\r\n---\r\n\r\n# Lists\r\n## Ul 箇条書きリスト\r\nハイフン`-`、プラス`+`、アスタリスク`*`のいずれかを先頭に記述。\r\nネストはタブで表現。\r\n\r\n```\r\n- リスト1\r\n    - リスト1_1\r\n        - リスト1_1_1\r\n        - リスト1_1_2\r\n    - リスト1_2\r\n- リスト2\r\n- リスト3\r\n```\r\n\r\n- リスト1\r\n    - リスト1_1\r\n        - リスト1_1_1\r\n        - リスト1_1_2\r\n    - リスト1_2\r\n- リスト2\r\n- リスト3\r\n\r\n\r\n# Ol 番号付きリスト\r\n番号.を先頭に記述します。ネストはタブで表現します。\r\n番号は自動的に採番されるため、すべての行を1.と記述するのがお勧めです。\r\n\r\n```\r\n1. 番号付きリスト1\r\n    1. 番号付きリスト1-1\r\n    1. 番号付きリスト1-2\r\n1. 番号付きリスト2\r\n1. 番号付きリスト3\r\n````\r\n\r\n1. 番号付きリスト1\r\n    1. 番号付きリスト1-1\r\n    1. 番号付きリスト1-2\r\n1. 番号付きリスト2\r\n1. 番号付きリスト3\r\n\r\n# Span Elements\r\nLink リンク\r\n[表示文字](URL)でリンクに変換されます。\r\n\r\n```\r\n[Google](https://www.google.co.jp/)\r\n```\r\n[Google](https://www.google.co.jp/)\r\n\r\n\r\n# 強調\r\n## em\r\nアスタリスク`*`もしくはアンダースコア`_`1個で文字列を囲みます。\r\n\r\n```\r\nこれは *イタリック* です\r\nこれは _イタリック_ です\r\n```\r\n\r\nこれは *イタリック* です\r\nこれは _イタリック_ です\r\n\r\n\r\n## strong\r\nアスタリスク`*`もしくはアンダースコア`_`2個で文字列を囲みます。\r\n\r\n\'\'\'\r\nこれは **ボールド** です\r\nこれは __ボールド__ です\r\n\'\'\'\r\n\r\nこれは **ボールド** です\r\nこれは __ボールド__ です\r\n\r\n## em + strong\r\nアスタリスク`*`もしくはアンダースコア`_`3個で文字列を囲みます。\r\n\r\n```\r\nこれは ***イタリック＆ボールド*** です\r\nこれは ___イタリック＆ボールド___ です\r\n```\r\nこれは ***イタリック＆ボールド*** です\r\nこれは ___イタリック＆ボールド___ です\r\n\r\nImages 画像\r\n先頭の!で画像のと認識されます。画像の大きさなどの指定をする場合はimgタグを使用します。\r\n\r\n```\r\n![alt](/static/pics/pic1.png)\r\n```\r\n![alt](/static/pics/pic1.png)\r\n\r\n````\r\n<img src=\"/static/pics/pic1.png\" width=\"200\" height=\"200\">\r\n```\r\n<img src=\"/static/pics/pic1.png\" width=\"200\" height=\"200\">\r\n\r\n# Table 表\r\n-と|を使ってtableを作成します。\r\n\r\n```\r\nMarkdown | Less | Pretty\r\n--- | --- | ---\r\n*Still* | `renders` | **nicely**\r\n1 | 2 | 3\r\n```\r\nMarkdown | Less | Pretty\r\n--- | --- | ---\r\n*Still* | `renders` | **nicely**\r\n1 | 2 | 3',1,'min'),(4,1562497531,1562497531,'faviconの使い方\n','### ファビコンの付け方\r\n\r\n#### HTMLのヘッダーに下記文を追加し、かつimagesフィルダーにfavicon.icoを用意しておけば、ブラウザが自動的にGETしにくる\r\n```html\r\n  <link rel=\"icon\" href=\"/images/favicon.ico\">\r\n```\r\n\r\n例：\r\n```html\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\r\n   <head>\r\n  　　<!-- meta -->\r\n  　　<meta charset=\"utf-8\">\r\n  　　<!-- style -->\r\n  　　<link rel=\"stylesheet\" href=\"/static/css/index.min.css\" media=\"all\">\r\n　　  <!-- favicon -->\r\n  　　<link rel=\"icon\" href=\"/images/favicon.ico\">\r\n  　　<title>html title </title>\r\n　</head>\r\n　<body>\r\n　</body>\r\n</html>\r\n```',1,'min'),(5,1562497531,1562497531,'gitのよくある使い方','# よくあるGITの使い方\r\n1. 普通にローカルでフォルダを作って、コーディングを行う\r\n1. でGITにCOMMITする\r\n```\r\ngit commit -m \'任意のメッセージ\'\r\n```\r\n\r\n1. 他のところでもソースを見たいなあ、パソコン壊れた時は困るなあと思い、githubにでもアップロードしたいなあ\r\n1. なのでgithubで任意の名前のrespositoryを作ろう\r\n1. でgitは自動的に下記のリンクを生成してくれるので、コピーして上げましょう\r\n```\r\nhttps://github.com/<user name>/<respository name>.git\r\n``\r\n1. ローカルのフォルダーに移動して、下記のコマンドを打とう（1COMMITしていることが全体だよ）\r\n```\r\ngit remote add origin https://github.com/<user name>/<respository name>.git\r\n```\r\n1.それで、githubのwebsiteにアップロードしましょう\r\n```\r\ngit push -u origin master\r\n```\r\n※自分一人だけ作業しているので、masterに直接アップロード\r\n※windowsとかはdesktop applicatonあるので、GUI画面なので、便利かも',1,'min'),(6,1562497531,1562497531,'Well Know Ports','ポート番号 | 用途\r\n--- | --- \r\n20 |  FTPデータ転送ポート\r\n21 | FTPコントロールポート\r\n22 |  SSH\r\n23 |  Telnet\r\n25 | SMTP\r\n53 | DNS\r\n67  |  DHCP（サーバ）\r\n68  |   DHCP（クライアント）\r\n80 | HTTP\r\n110 | POP3\r\n443 | HTTPS\r\n',1,'min'),(7,1562497531,1562497531,'SNOWのdev instanceの自動アクティベート','# SNOWのdevインスタンスを自動的にアクティベートする\r\n## 前提条件\r\n- NodeJsがインストールされていること\r\n- puppeteerがインストールされていること\r\n\r\n## 実装部分\r\n- 開発の行為をやる\r\n\r\n```javascript\r\nconst puppeteer = require(\'puppeteer\');\r\nasync function main() {\r\n    const browser = await puppeteer.launch({args: [\'--no-sandbox\', \'--disable-setuid-sandbox\']});\r\n    const page = await browser.newPage();\r\n    console.log(\"Opening page\");\r\n    await page.goto(\'https://dev<your instance id>.service-now.com/\', {waitUntil: \'networkidle0\', timeout:0}); // wait until page load\r\n    console.log(\"Page opened\");\r\n\r\n    console.log(\"Inputting username\");\r\n    const frame = await page.frames().find(f => f.name() === \'gsft_main\');\r\n    await (await frame.$(\'#user_name\')).type(\'<your_user_name>\');\r\n    await (await frame.$(\'#user_password\')).type(\'<your_password>\');\r\n    const login = await frame.$(\'#sysverb_login\')\r\n\r\n\r\n    await Promise.all([\r\n        login.click(),\r\n        await page.waitForNavigation({ waitUntil: \'networkidle0\'}),\r\n    ]);\r\n\r\n    const page2 = await browser.newPage();\r\n    await page2.goto(\'<any business rule\'s link>\', { waitUntil: \'networkidle0\' }); // wait until page load\r\n    const frame2 = await page2.frames().find(f => f.name() === \'gsft_main\')\r\n    const name = await frame2.$(\'input[id=\"sys_script.name\"]\')\r\n    let d = new Date()\r\n    let input_value = d.toGMTString().split(\",\").join()\r\n    await name.click({clickCount: 3});\r\n    await name.type(input_value, {delay: 20});\r\n\r\n    console.log(\"click update\");\r\n    const update = await frame2.$(\'#sysverb_update\')\r\n    await update.click()\r\n    pages = await browser.pages();\r\n    pages.forEach((page) => page.close());\r\n    await browser.close();\r\n}\r\n\r\nmain();\r\n```\r\n\r\n- 念の為にステータスも更新する\r\n\r\n```javascript\r\nconst puppeteer = require(\'puppeteer\');\r\nasync function main() {\r\n    const browser = await puppeteer.launch({args: [\'--no-sandbox\', \'--disable-setuid-sandbox\']});\r\n    const page = await browser.newPage();\r\n    await page.goto(\'https://developer.servicenow.com/app.do#!/instance\', { waitUntil: \'networkidle0\' }); // wait until page load\r\n    await page.waitForNavigation({ waitUntil: \'networkidle0\' });\r\n// Input username\r\n    console.log(\"Inputting username\");\r\n    await page.type(\'#username\', <your-user-name>);\r\n    await page.type(\'#password\', \'<your-login-password>\');\r\n    console.log(\"Username input completed\");\r\n\r\n// click and wait for navigation\r\n    await Promise.all([\r\n        await page.click(\'#submitButton\'),\r\n        await page.waitForNavigation({ waitUntil: \'networkidle0\' }),\r\n    ]);\r\n\r\n    console.log(\"Open new page\");\r\n    const page2 = await browser.newPage();\r\n    await page2.goto(\'https://developer.servicenow.com/app.do#!/instance\', { waitUntil: \'networkidle0\' }); // wait until page load\r\n    // await page2.waitForNavigation({ waitUntil: \'networkidle0\' });\r\n    await page2.click(\'#refresh_status\');\r\n    console.log(\"clicked\")\r\n    pages = await browser.pages();\r\n    pages.forEach((page) => page.close());\r\n    await browser.close();\r\n}\r\n\r\nmain();\r\n```\r\n\r\n[ソースはこちらでダウンロードできる](https://github.com/fanmin2019/snowAutoActivate)\r\n\r\n## スケジュール実行\r\n```\r\n24 */4 * * * node /tmp/snowlogin/update_business_rule.js >> /tmp/run.log\r\n50 */4 * * * node /tmp/snowlogin/refresh_status.js >> /tmp/run.log\r\n```',1,'min'),(8,1562497531,1562497531,'Proxy環境でnode jsのnpmを正常に通信させる方法','# Proxy環境でnode jsのnpmを正常に通信させる方法\r\n## 1.下記コマンドでwindowsとしてデフォルトに設定しているProxy設定を見ることができる\r\n```\r\nnpm config list\r\n```\r\n\r\n## 出力結果\r\n\r\n```\r\nC:\\Users\\XXXX\\Downloads>npm config list\r\n; cli configs\r\nmetrics-registry = \"http://registry.npmjs.org/\"\r\nscope = \"\"\r\nuser-agent = \"npm/6.9.0 node/v10.16.0 win32 ia32\"\r\n\r\n; userconfig C:\\Users\\XXXX\\.npmrc\r\nhttps-proxy = \"https://127.0.0.1:8080/\"\r\nproxy = \"http://127.0.0.1:8080/\"\r\nregistry = \"http://registry.npmjs.org/\"\r\n\r\n; builtin config undefined\r\nprefix = \"C:\\\\Users\\XXXX\\AppData\\\\Roaming\\\\npm\"\r\n\r\n; node bin location = C:\\Program Files\\nodejs\\node.exe\r\n; cwd = C:\\Users\\XXXX\\Downloads\r\n; HOME = C:\\Users\\XXXX\r\n; \"npm config ls -l\" to show all defaults.\r\n```\r\n\r\n## 2.上で得たproxy情報に認証情報を付け加えることが必須\r\n```\r\nnpm config set proxy http://<userid>:<password>@<server-address>:<port>\r\nnpm config set https-proxy http://<userid>:<password>@<server-address>:<port>\r\n```\r\n\r\n```\r\nnpm config set proxy http://fanmin:Hoge1234@127.0.0.1:8080\r\nnpm config set https-proxy http://fanmin:Hoge1234@127.0.0.1:8080\r\n```\r\n\r\n## Proxy設定を再度確認する\r\n```\r\nnpm config list\r\n```\r\n\r\n## 出力結果\r\n```\r\nC:\\Users\\XXXX\\Downloads>npm config list\r\n; cli configs\r\nmetrics-registry = \"http://registry.npmjs.org/\"\r\nscope = \"\"\r\nuser-agent = \"npm/6.9.0 node/v10.16.0 win32 ia32\"\r\n\r\n; userconfig C:\\Users\\XXXX\\.npmrc\r\nhttps-proxy = \"http://fanmin@Hoge1234@127.0.0.1:8080/\"\r\nproxy = \"http://fanmin@Hoge1234@127.0.0.1:8080/\"\r\nregistry = \"http://registry.npmjs.org/\"\r\n\r\n; builtin config undefined\r\nprefix = \"C:\\\\Users\\\\XXXX\\\\AppData\\\\Roaming\\\\npm\"\r\n\r\n; node bin location = C:\\Program Files\\nodejs\\node.exe\r\n; cwd = C:\\Users\\XXXX\\Downloads\r\n; HOME = C:\\Users\\XXXX\r\n; \"npm config ls -l\" to show all defaults.\r\n```\r\n\r\n## 4.試しにExpressをinstall\r\n```\r\nnpm install express\r\n```',1,'min'),(9,1562497531,1562497531,'IntelliJ系列如何竖选文本','如果需要使用，我们可以选中代码，右键单击，在弹出的菜单中选中【Column Selection Mode】列选中模式。当然，你也可以使用快捷键【shift + command + 8】（window环境可以参考Idea提示） \r\n',1,'min'),(10,1562497531,1562497531,'canvasを使って図を反転する方法','# canvasを使って図を水平方向に反転する方法（コード）\r\n```javascript\r\n\r\n//canvasの現状を一時保存\r\ncontext.save()\r\n\r\n//図のX軸の中心点のX座標を取得\r\nvar x = this.x + this.w / 2\r\n\r\n//yは反転しない\r\n//まずはcanvasを右にx単位水平移動する\r\ncontext.translate(x, 0)\r\n\r\n//canvasを左右反転する\r\ncontext.scale(-1, 1)\r\n\r\n//キャンバスを左へx単位水平移動する\r\ncontext.translate(-x, 0)\r\n\r\n//画像を描く\r\ncontext.drawImage(this.texture, this.x, this.y)\r\n\r\n//キャンバスを一時保存した状態に戻す\r\ncontext.restore()\r\n```\r\n\r\n# よく理解するための図解\r\n![hanten1](https://github.com/fanmin2019/minBlog/blob/master/%E5%9B%B3%E5%BD%A2%E3%81%AE%E5%8F%8D%E8%BB%A21.png?raw=true)\r\n![hanten2](https://github.com/fanmin2019/minBlog/blob/master/%E5%9B%B3%E5%BD%A2%E3%81%AE%E5%8F%8D%E8%BB%A22.png?raw=true)',1,'min'),(11,1562497531,1562497531,'このサイトのリリース方法','## 1.ローカルで開発を実施し、テストをしてから、gitに資材をコミットする\r\n## 2.バーチャルサーバにて、gitから更新された資材を取得し、アプリケーションが問題なく動くことを確認\r\n## 3.VPSにログインし、gitから更新された資材を取得し、必要に応じてデータベースのリセットをしたり、サーバの再起動を行う。\r\n- データベースのリセットを伴う場合、必ず事前にバックアップを取得すること\r\n- **本番環境で何か問題が起きたとしても、本番環境で資材を編集しないこと！！**\r\n',1,'min'),(12,1564312935,1564312935,'我们要怎样去问问题',' # 我们问问题的场景：\r\n* 想做一件事\r\n* 设计一套方案（或者不设计方案，先尝试想一些看起来有用的事）\r\n* 按方案（直觉）开始实际去做\r\n* 做到某一步的时候被一个问题卡住了\r\n* 自己想办法尝试解决\r\n* 发现自己解决不了，就找人问\r\n\r\n# 我们问问题时候的问题\r\n* 信息不全（只给出自认为有问题的地方，不给出完整信息）\r\n* 目的不明确（声称目的是想做一件事，其实是想通过这件事达到其他真正的目的）\r\n* 沉迷于细节（自己解决问题的过程中钻牛角尖，拘泥于不重要的细节，导致不反复提问就无法解决问题，浪费时间）\r\n* 提供不完整或不实信息（为了面子，或者出于对对方的不完全信任，隐藏或编造某些信息，导致问题解决不了）\r\n* \r\n\r\n# 双赢的提问原则\r\n在一个双赢的提问中，需要注意以下原则\r\n* 尽量完整的给出问题相关信息，不要遗漏和隐瞒\r\n* 让自己的眼光回到全局，而不要局限在细节中\r\n* 不要忘记自己的最初目标，以免解决问题的过程中走偏\r\n\r\n# 你到底需要提高哪些信息\r\n1，你最初的目的是什么？（你最终想做一件什么事？）\r\n你的做法可能是错误的，描述需求可以帮助他人发现你南辕北辙的解决方案。\r\n你的需求可能是错的，给出目的可以帮助他人发现你错误的需求。\r\n\r\n2，在你的计划中，你打算通过怎样一系列的步骤来达成这个目的？\r\n描述思路有助于他人搞懂你在做的事情、搞懂你遇到的问题\r\n你解决问题的想法和思路可能是错的，描述清楚有助于发现错误\r\n\r\n3，你在这个过程中，进行到哪一步的时候遇到了什么问题？尽可能详尽的给出遇到这个问题时的相关信息（包括你在试图解决的过程中得到的信息）\r\n对具体信息的描述可以帮助他人分析具体问题，所以要给出错误的具体、完整的信息，而不是残缺的截图或者零散的几句描述\r\n尽可能的描述你的操作步骤，以便让对方可以重现出你遇到的错误，这样才能针对具体的问题进行进一步的解答\r\n\r\n4，给出具体的完整可执行（或可重现问题）的代码（如果有的话）\r\n如果不尽量给出完整、简化、可运行、可重现问题的代码，对方很难定位具体问题，也就无从解决问题了\r\n\r\n实际上，这个方法不仅仅只能帮助你向他人求助\r\n经过之前两年对提问表格的推广，收到很多反馈说，在利用这个工具提问的过程中直接就想明白了自己的问题。',1,'min'),(13,1564583150,1564583150,'MySQLのデータベースとテーブルをバックアップ＆リストア方法','# MySQLのデータベースとテーブルをバックアップ＆リストア方法\r\n\r\n##まずはファイル関連の権限を確認する\r\n-mysqlにログインして、以下のコマンドを発行\r\n```\r\nSELECT @@global.secure_file_priv;\r\n```\r\n\r\n-もし結果はNULL或いは空白の場合、特に対処しなくてもいい\r\n-もし結果はNULLでも空白でもない場合、特定のフォルダを使うのは面倒なので、デフォルトの設定をクリアしたほうがいい\r\n```\r\nmysql> SELECT @@global.secure_file_priv;\r\n+---------------------------+\r\n| @@global.secure_file_priv |\r\n+---------------------------+\r\n| NULL                      |\r\n+---------------------------+\r\n1 row in set (0.00 sec)\r\n```\r\n\r\n-クリアする方法は以下の通り\r\n```\r\nsudo vim /etc/my.cnf\r\n# 以下を書き込む\r\n[mysqld]\r\nsecure-file-priv = \"\"\r\n````\r\n```\r\n#再起動を行う\r\nmysql.server restart\r\n```\r\n\r\n\r\n-空になったことを確認\r\n```\r\nmysql> SELECT @@global.secure_file_priv;\r\n+---------------------------+\r\n| @@global.secure_file_priv |\r\n+---------------------------+\r\n|                           |\r\n+---------------------------+\r\n1 row in set (0.00 sec)\r\n````\r\n\r\n## データベースごとにバックアップを取る方法\r\n```\r\nmysqldump -u <db_username> -p db_name  > db_name.sql\r\n```\r\n例：\r\n```\r\nmysqldump -u admin -p min_site > Min_site.sql\r\n```\r\n\r\n## テーブルごとにバックアップを取る方法\r\n```\r\nmysqldump -u <db_username> -p db_name table_name > table_name.sql\r\n```\r\n例：\r\n```\r\nmysqldump -u admin -p min_site Blogs > Blogs.sql\r\n```\r\n\r\n## テーブル或いはデータベースのレストア\r\n**ただし、元のデータを全部上書きするので、要注意**\r\n\r\n```\r\nmysql> source <full_path>/backup.sql\r\n```\r\n\r\n例:\r\n```\r\nmysql> source /tmp/worktmp/Blogs.sql\r\n```',1,'min'),(14,1564583150,1564583150,'分散開発モード下のgitによるバージョン管理','# まずはリモートのコードを保存してくれる倉庫（例えばgithub)から資材をクローンする\r\nクローンはgithubのユーザー名とパスワードは問われない\r\n# 次は何かしらの修正を行う\r\n# でそのファイルをワークスペースに追加して、つまりステータスをgitに管理してもらう\r\n```\r\ngit add <file name>\r\n```\r\n\r\n#そしてコミットする\r\n```\r\ngit commit -m \"message\"\r\n```\r\n#そしてリモートの倉庫にコードをアップロードするよ\r\n\'\'\'\r\ngit push\r\n\'\'\'\r\ngithubのユーザー名とパスワードは問われる',1,'min'),(15,1565426602,1565426602,'OSに関するいくつかの概念','# 内存泄露\r\n内存泄漏就是由于程序的错误，使得程序未能释放已经不再使用的内存,在释放该段内存之前就失去了对该段内存的控制\r\n然后别的程序就有可能会看到这些内存。重启或者扩充内存可以改善这个问题\r\n\r\n\r\n# 进程和线程\r\n进程是操作系统管理软件的一个单位。\r\n一个操作系统可以启动很多进程，\r\n同一个软件为了提高自己的速度，可以启动多个进程。\r\n但是由于多进程无法共享内存，所以编程难度大。\r\n线程就是把程序在一个进程里并行的多个执行。\r\n一个进程里面启动多个线程可以解决内存共享问题，\r\n同时可以享受到多核cpu的好处。\r\n\r\n# 线程安全和原子性\r\n线程安全就是要保证线程正确执行，使用的资源不会被污染或别的线程占用\r\n原子性就是一段程序执行的最小的单位\r\n通过要么全部执行，要么一行都不执行来保证\r\n\r\n# 死锁\r\n死锁就是两个或以上线程同时等待对方解锁资源，造成双方都无法正确释放资源。产\r\n生死锁的原因是因为足够考虑到进程在运行过程中，请求和释放资源的顺序不当会造成的问题。\r\n解决的思路之一是将系统中的所有资源统一编号，进程可在任何时刻提出资源申请，但所有申请必须按照资源的编号顺序（升序）提出\r\n\r\n# 虚拟内存技术是什么\r\n虚拟内存是计算机系统内存管理的一种技术。\r\n它能够把物理上的多个物理内存的碎片整合起来，\r\n让应用程序看起来是一片连续可用的内存。\r\n它还可以把处于不活动状态的程序以及它们的数据存到磁盘上，\r\n把需要的程序及其数据从磁盘加载到内存中。\r\n它能够提高物理内存的使用效率，让大型程序也容易跑起来\r\n\r\n# 自动垃圾回收\r\n当对象或者资源不再被使用时，自动清空其占用的内存\r\n一个对象如果没有任何引用指向它，它就被认为是垃圾对象\r\n## 垃圾对象什么时候被回收？\r\n堆内存快不够用的时候。cup空闲的时候。\r\ngc会自动调用被回收对象的finalize()\r\n被回收的对象，要在finalize()方法里释放自己占有外部资源\r\n比如：停止计时器、断开数据库的连接、关闭文件等等\r\n## 能否主动要求gc去回收垃圾呢？\r\n可以主动申请，但是收不收gc说了算。\r\n如何申请，System.gc();\r\n\r\n## 优点：\r\n它能使编程效率提高。在没有垃圾回收机制的时候，可能要花许多时间来解决一个难懂的存储器问题。\r\n在用Java语言编程的时候，靠垃圾回收机制可大大缩短时间。\r\n其次是它保护程序的完整性， 垃圾回收是Java语言安全性策略的一个重要部份。 \r\n## 缺点：\r\n垃圾回收的一个潜在的缺点是它的开销影响程序性能。Java虚拟机必须追踪运行程序中有用的对象，而且最终释放没用的对象。这一个过程需要花费处理器的时间。其次垃圾回收算法的不完备性，早先采用的某些垃圾回收算法就不能保证100%收集到所有的废弃内存。当然随着垃圾回收算法的不断改进以及软硬件运行效率的不断提升，这些问题都可以迎刃而解。\r\n\r\n# 调度\r\n計算機科学においてスケジューリングは、スレッドやプロセスやデータの流れについて、システム資源（例えば、プロセッサ時間、通信帯域など）へのアクセスを与える方法である。システムを効果的に負荷分散するため、あるいはターゲットの Quality of Service を保証するためになされる。スケジューリングアルゴリズムは、マルチタスク（同時に複数のプロセスを実行）や多重化（複数のデータの流れを同時に転送）の発展とともに進化してきた。\r\nスケジューラの主な関心事は以下の通りである。\r\n* スループット - 単位時間ごとに実行完了するプロセスの総数\r\n* レイテンシ\r\n        * ターンアラウンド - プロセスの発行から完了までの総時間\r\n        * 応答時間 - 要求を送ってから最初の応答が生成されるまでにかかる時間\r\n* 公平さ/待ち時間 - 各プロセスに平等にCPU時間を割り当てること（またより一般的には、各プロセスの優先度に応じた適切な時間）\r\nスループットを最大化し、レイテンシを最小化するのがスケジューリングの目標である。しかし実際にはこれらの目標は同時に満たすのが難しく、スケジューラは適当なところで妥協した実装とすることが多い。ユーザーのニーズと目的によって上記のいずれかに力点を置く。\r\nファクトリーオートメーションのための組み込みシステム（例えば産業用ロボット）などのリアルタイム環境では、スケジューラがプロセスの時間制限（デッドライン）を満たすことを保証する必要がある。これは、システムの安定性を保つ上で重要である。\r\n2.1FIFO\r\n2.2最小残余時間優先\r\n2.3固定優先度プリエンプティブ・スケジューリング\r\n2.4ラウンドロビン・スケジューリング\r\n2.5多段キュースケジューリング',1,'min'),(16,1565426602,1565426602,'ネットワークプログラミングに関するいくつかの概念','# 三次握手是什么\r\n三次握手是TCP建立链接的准备工作，首先是客户端发出一个SYN给想要进行通信的对象，比如说服务器。如果这个服务器已经准备就绪，就会给客户端返回一个ACK并且加上服务器自己的SYN，让客户端确认是否能收到服务器的SYN，如果服务器也能收到，那么服务器端就给客户端发一个ACK。经过这个过程以后，transport层的TCP链接正式形成。TCP和UDP不同，需要建立可信赖并且严格控制的链接，所以需要在客户端和服务器端之间都做好确认。\r\n\r\n# Socket是什么\r\nSocket是应用层和传输层之间的抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。它从应用层那里获取目的IP和目的端口，然后传给OS控制的TCP/IP协议群。客户端的socket是每次客户端进行网络连接时，OS自动分配的，而服务器的socket则是在启动服务器的时候就向OS请求好的，每建立一个请求就会复制一份原有的socket，保证每个通信都是独立的，可唯一表示的。\r\n\r\n# 浏览器缓存\r\n浏览器缓存是为了节约网络的资源加速浏览，浏览器在发出请求前，会先看用户磁盘上有没有要请求的文件，如果有的话直接返回磁盘上的文件，如果没有的话，才真正对服务器发出请求。这样就可以加速网页显示了。\r\n\r\n# SOAP是什么\r\nSOAP也叫简单对象访问协议是web service的一种，相对来说比较轻量和简单，是基于XML的协议。它主要用来在WEB上交换结构化的和固化的信息。\r\n\r\n# HTTP1.0和HTTP1.1\r\n在HTTP1.0中，每对Request/Response都使用一个新的连接，这样会造成网络处理变慢，因为每新建一个新的连接，就会重新走一轮TCP三次握手的流程。而HTTP 1.1则支持持久连接Persistent Connection, 并且默认使用persistent  connection. 在同一个tcp的连接中可以传送多个HTTP请求和响应. 多个请求和响应可以重叠，多个请求和响应可以同时进行. 更加多的请求头和响应头(比如HTTP1.0没有host的字段)，大大改善了网络使用效率。\r\n\r\n# RPC\r\nRPC就是要像调用本地的函数一样去调远程函数\r\n当客户端需要进行远程调用时，它就查一下这个表，找出相应的Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码\r\n这时候就需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。\r\n远程调用往往用在网络上，客户端和服务端是通过网络连接的。所有的数据都需要通过网络传输，因此就需要有一个网络传输层。网络传输层需要把Call ID和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端\r\n\r\n# CGI和WSGI\r\nCGI（Common Gateway Interface，通用网关接口 ），描述了服务器和客户端请求处理程序（通常就是浏览器）之间传输数据的一种标准。\r\nWSGI（Web Server Gateway Interface）是专门为Python定义的Web服务器和Web应用程序或框架之间的一种简单而通用的接口。\r\n当Web服务器接收到一个请求后，可以通过Socket把环境变量和一个callback回调函数传递给后端Web应用程序，Web应用程序处理完成后，调用callback函数，把结果返回给WebServer。\r\n1. 异步化，通过callback将Web请求的工作拆解开，可以很方便地在一个线程空间里同时处理多个Web请求\r\n2. 方便进行各种负载均衡和请求转发，不会造成后端Web应用阻塞\r\n\r\n\r\n#「C10K問題」\r\nクライアント1万台問題とは、ハードウェアの性能上は問題がなくても、あまりにもクライアントの数が多くなるとサーバがパンクする問題のこと。 万を超える接続に対応するプロセスやスレッドを生成するとメモリ上にプロセスやスレッドの管理領域が確保され、使われるメモリサイズもばかにならない。\r\n\r\n# 四次挥手\r\n假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说\"我Client端没有数据要发给你了\"，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，\"告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息\"。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，\"告诉Client端，好了，我这边数据发完了，准备好关闭连接了\"。Client端收到FIN报文后，\"就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，\"就知道可以断开连接了\"。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了',1,'min'),(17,1565426602,1565426602,'DBに関するいくつかの概念','# 乐观锁和悲观锁是什么？\r\n乐观锁是假设每次读取数据的时候别人都不会改\r\n所以不上锁，但是在更新的时候，用版本或者更新时间\r\n去判断在此期间有没有别的人去更新。适合读比较多写比较少的场景。\r\n\r\n悲观锁是假设每次在读取数据的时候，一定会有人同时改数据，\r\n所以就在读取数据的时候先上锁，别人如果想读取这个数据，\r\n就必须等到锁被解除。适合写比较多，读比较少的场景。\r\n\r\n# Redis 是什么？常见用处？有什么缺点？\r\nRedis是一款内存高速缓存数据库。使用了一个key-value存储系统，它支持丰富的数据类型，如：string、list、set、zset(sorted set)、hash，Redis以内存作为数据存储介质，所以读写数据的效率极高，储存在Redis中的数据是持久化的，断电或重启后，数据也不会丢失。因为Redis的存储分为内存存储、磁盘存储和log文件三部分，重启后，Redis可以从磁盘重新将数据加载到内存中，这些可以通过配置文件对其进行配置，正因为这样，Redis才能实现持久化。将这种热点数据存到Redis（内存）中，要用的时候，直接从内存取，极大的提高了速度和节约了服务器的开销\r\n它的缺点是由于是内存数据库，所以，单台机器，存储的数据量，跟机器本身的内存大小。虽然redis本身有key过期策略，但是还是需要提前预估和节约内存。如果内存增长过快，需要定期删除数据。  如果进行完整重同步，由于需要生成rdb文件，并进行传输，会占用主机的CPU，并会消耗现网的带宽。不过redis2.8版本，已经有部分重同步的功能，但是还是有可能有完整重同步的。比如，新上线的备机。修改配置文件，进行重启，将硬盘中的数据加载进内存，时间比较久。在这个过程中，redis不能提供服务。 \r\n\r\n# MyISAM和InnoDB\r\nMyISAM存储: 如果表对事务要求不高，同时是以查询和添加为主的，我们考虑使用myisam存储引擎,比如bbs 中的 发帖表，回复表，还有批量添加MyISAM效率高\r\nINNODB 存储: 对事务要求高，保存的数据都是重要数据，我们建议使用INNODB,比如订单表，账号表。\r\n【面试重点】MyISAM 和 INNODB的区别？\r\n1. 事务安全（MyISAM不支持事务，INNODB支持事务）\r\n2. 外键 MyISAM 不支持外键， INNODB支持外键. \r\n3. 锁机制（MyISAM时表锁，innodb是行锁）\r\n4. 查询和添加速度（MyISAM批量插入速度快）\r\n5. 支持全文索引（MyISAM支持全文索引，INNODB不支持全文索引）\r\n6.MyISAM内存空间使用率比InnoDB低\r\nMemory 存储，比如我们数据变化频繁，不需要入库，同时又频繁的查询和修改，我们考虑使用memory, 速度极快. （如果mysql重启的话，数据就不存在了）',1,'min'),(18,1565426602,1565426602,'データ構造の基本と特徴','# 时间复杂度 和 大 O 记法\r\n时间的复杂度是用来表达算法复杂度的一种维度，\r\n在计算机科学中，算法的时间复杂度是一个函数，它定性描述了该算法的运行时间。\r\n它的输入值是一段字符串，然后表达是代表基本操作重复执行的次数，\r\n进而分析函数随变量的变化来确定数量级，数量级用O表示\r\n常见的时间复杂度有以下七种：O（1）常数型；O（log2N）对数型，O（N）线性型，O（Nlog2N）二维型，O（N^2)平方型，O（N^3)立方型，O（2^N）指数型。',1,'min'),(19,1565426602,1565426602,'Docker学習メモ','# Docker的介绍\r\nDocker的镜像就类似是光盘\r\n而Docker容器是复制镜像\r\n\r\n# 启动docker的方法\r\n启动docker的桌面程序\r\n然后login进去\r\n就可以看到它启动了\r\n\r\n## 手动启动容器\r\n```bash\r\ndocker run -d -t -p 8000:5000 --name demo ubuntu:18.04\r\n-d 让容器在后台运行\r\n-t 运行一个空白的镜像\r\n-p 本机端口映射到虚拟机端口\r\n-name 虚拟机的名字\r\nubuntu xxxx 你要的镜像的版本\r\n```\r\n\r\n## 启动容器的时候报错\r\n```bash\r\nhansatoshis-MacBook-Pro:Downloads fanmin$ docker run -d -t -p 8000:5000 --name demo2 ubuntu:18.04\r\n9149168fe907f70e0d420359dadb6c53dcc27945197855da5265c3706c6f7d74\r\ndocker: Error response from daemon: driver failed programming external connectivity on endpoint demo2 (63b4ef3cc78d868786caa4b547fe72070e7394e184a7fbcd45423cce06818985): Bind for 0.0.0.0:8000 failed: port is already allocated.\r\n```\r\n这个错误是端口被别的容器占用了，但是其实容器本身已经生成，只是并没有被启动而已\r\n那么能做的事情就是\r\n1.删除那个跟你同端口的容器\r\n    ```docker rm -f demo```\r\n\r\n2. 然后把自己删掉，然后再启动一次\r\n```bash\r\ndocker rm demo\r\ndocker run -d -t -p 8000:5000 --name demo2 ubuntu:18.04\r\n``` \r\n   \r\n2’. 要么自己改一个名字再来一次\r\n ```bash\r\ndocker run -d -t -p 8000:5000 --name demo3 ubuntu:18.04\r\n```\r\n\r\n\r\n# 在容器里面安装一些需要的软件\r\n```bash\r\ndocker exec demo apt update\r\ndocker exec demo apt -y install python3 python3-pip\r\ndocker exec demo pip3 install flask\r\ndocker stop <containerId> && docker start <containerId>\r\ndocker restart <containerId>\r\n```\r\n\r\n# 启动flask程序\r\n```bash\r\n#在docker里面创建一个文件夹\r\ndocker exec demo mkdir /code\r\n\r\n#复制文件\r\ndocker cp a.py \"demo:/code/a.py\"\r\n\r\n#运行软件\r\ndocker exec demo python3 /code/a.py\r\n```\r\n\r\n# 用脚本方式配置容器\r\n#停止程序 Ctrl-C\r\n注意：在docker环境下，这样操作并不会真正的终止程序，它只是把程序放到后台运行而已\r\n所以需要把容器停止了\r\n```bash\r\n#停止容器\r\ndocker stop demo\r\n\r\n#重新弄一个容器\r\ndocker run -d -t -p 8000:5000 --name demo1 ubuntu:18.04\r\n\r\n#然后把脚本copy进去\r\ndocker exec demo1 mkdir /code\r\ndocker cp ./install.sh \"demo1:/code/install.sh”\r\ndocker cp ./run.sh \"demo1:/code/run.sh”\r\ndocker cp ./a.py \"demo1:/code/a.py”\r\n\r\n#然后就执行程序即可\r\ndocker exec demo1 bash /code/install.sh\r\ndocker exec demo1 bash /code/run.sh\r\n```\r\n\r\n# 容器的其他操作\r\n```bash\r\n#启动一个容器（如果已经启动也不会报错）\r\ndocker start demo\r\n\r\n#显示正在运行的容器\r\ndocker ps\r\n\r\n#停止容器\r\ndocker stop demo\r\n\r\n#查看所有容器\r\ndocker ps -a\r\n\r\n#删除容器\r\ndocker rm demo\r\ndocker rm -f demo1\r\n```\r\n\r\n',1,'min'),(20,1565426602,1565426602,'Dockerfileの書き方','Dockerfileはカスタマイズしたイメージ、同時にたくさんのコンテナを作るのにとても便利。\r\n\r\n# Dockerfile的写法\r\n```bash\r\n# 在 Dockerfile 文件中 # 是注释\r\n# FROM 用于指定构建镜像使用的基础镜像\r\nFROM ubuntu:18.04\r\n\r\n\r\n# RUN 用于在构建镜像的时候在镜像中执行命令\r\n# 这里我们安装 python3 和 flask web 框架\r\nRUN apt update\r\nRUN apt -y install python3 python3-pip\r\nRUN pip3 install flask\r\n\r\n\r\n# COPY 相当于命令的 docker cp\r\n# 把本机当前目录下的 app.py 文件拷贝到镜像的 /code/app.py\r\n# 和 docker cp 不同的是，COPY 会自动创建镜像中不存在的目录，比如 /code\r\nCOPY app.py /code/app.py\r\n\r\n\r\n# WORKDIR 用于指定从镜像启动的容器内的工作目录\r\nWORKDIR /code\r\n\r\n\r\n# CMD 用于指定容器运行后要执行的命令和参数列表\r\n# 这样从本镜像启动容器后会自动执行 python3 app.py 这个命令\r\n#\r\n# 由于我们已经用 WORKDIR 指定了容器的工作目录\r\n# 所以下面的命令都是在 /code 下执行的\r\nCMD [\"python3\", \"app.py\"]\r\n\r\n# ENTRYPOINT 参数可以用于指定容器运行后的入口程序\r\n# 但是这个参数在现在的意义已经很小了，忽略即可\r\n```\r\n\r\n# 用dockerfile制作镜像\r\n```bash\r\n# 在放有dockerfile的文件夹里，启动以下command\r\ndocker build -t webimage .\r\n\r\n# 查看本地拥有的镜像\r\ndocker images\r\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\r\nwebimage            latest              0774f9937820        3 minutes ago       475MB\r\nubuntu              18.04               4c108a37151f        7 weeks ago         64.2MB\r\n\r\n# 运行容器\r\ndocker run -p 8001:5000 --name demo2 webimage\r\n```\r\n\r\n',1,'min'),(21,1565538689,1565538689,'Dockerの永続化','#创建数据卷\r\ndocker volume create testvolume\r\n\r\n#列出所有的数据卷\r\ndocker volume ls\r\n\r\n#删除数据卷\r\ndocker volume rm testvolume',1,'min');
/*!40000 ALTER TABLE `Blog` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2019-08-12 19:41:14
